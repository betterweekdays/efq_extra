<?php

/**
 * Implements hook_field_storage_query().
 */
function EntityFieldQueryExtra_field_sql_storage_field_storage_query(EntityFieldQuery $query) {
  if ($query->age == FIELD_LOAD_CURRENT) {
    $tablename_function = '_field_sql_storage_tablename';
    $id_key = 'entity_id';
  }
  else {
    $tablename_function = '_field_sql_storage_revision_tablename';
    $id_key = 'revision_id';
  }
  $table_aliases = array();
  // Use base table if no conditions and only left joins.
  $first = TRUE;
  if (!empty($query->changeBaseTable)) {
    $select_query = db_select($query->changeBaseTable, $query->changeBaseTable);
    $field_base_table = $query->changeBaseTable;
    $first = FALSE;
    if ($field_base_table == 'node') {
      $base_id = 'nid';
    }
    if ($field_base_table == 'users') {
      $base_id = 'uid';
    }
    $select_query->addField($field_base_table, $base_id);
  }
  // Add tables for the fields used.
  $second_table_alias = FALSE;
  foreach ($query->fields as $key => $field) {
    $tablename = $tablename_function($field);
    // Every field needs a new table.
    $table_alias = $tablename . $key;
    $table_aliases[$key] = $table_alias;
    if (!$first) {
      if (!empty($query->changeBaseTable)) {
        $select_query->join($tablename, $table_alias, "$table_alias.$id_key = $field_base_table.$base_id");
      }
      else {
        $select_query->join($tablename, $table_alias, "$table_alias.entity_type = $field_base_table.entity_type AND $table_alias.$id_key = $field_base_table.$id_key");
      }
      if (empty($second_table_alias)) {
        $second_table_alias = $field_base_table;
      }
    }
    else {
      $select_query = db_select($tablename, $table_alias);
      // Allow queries internal to the Field API to opt out of the access
      // check, for situations where the query's results should not depend on
      // the access grants for the current user.
      if (!isset($query->tags['DANGEROUS_ACCESS_CHECK_OPT_OUT'])) {
        $select_query->addTag('entity_field_access');
      }
      $select_query->addMetaData('base_table', $tablename);
      if ($query->executeQuery) {
        $select_query->fields($table_alias, array('entity_type', 'entity_id', 'revision_id', 'bundle'));
      }
      else {
        $select_query->fields($table_alias, array('entity_id'));
      }
      $field_base_table = $table_alias;
      $first = FALSE;
    }
    if ($field['cardinality'] != 1 || $field['translatable']) {
      $select_query->distinct();
    }
  }
  if (empty($second_table_alias)) {
    $second_table_alias = $table_alias;
  }

  // Add field conditions. We need a fresh grouping cache.
  drupal_static_reset('_field_sql_storage_query_field_conditions');
  _field_sql_storage_query_field_conditions($query, $select_query, $query->fieldConditions, $table_aliases, '_field_sql_storage_columnname');

  // Add field meta conditions.
  _field_sql_storage_query_field_conditions($query, $select_query, $query->fieldMetaConditions, $table_aliases, '_field_sql_storage_query_columnname');

  if (isset($query->deleted) && empty($query->changeBaseTable)) {
    $select_query->condition("$second_table_alias.deleted", (int) $query->deleted);
  }

  // Is there a need to sort the query by property?
  $has_property_order = FALSE;
  foreach ($query->order as $order) {
    if ($order['type'] == 'property') {
      $has_property_order = TRUE;
    }
  }

  if ($query->propertyConditions || $has_property_order) {
    if (empty($query->entityConditions['entity_type']['value'])) {
      throw new EntityFieldQueryException('Property conditions and orders must have an entity type defined.');
    }
    $entity_type = $query->entityConditions['entity_type']['value'];
    if (empty($query->changeBaseTable)) {
      $entity_base_table = _field_sql_storage_query_join_entity($select_query, $entity_type, $field_base_table);
    }
    else {
      $entity_base_table = $query->changeBaseTable;
    }
    $query->entityConditions['entity_type']['operator'] = '=';
    foreach ($query->propertyConditions as $key => $property_condition) {
      // Handle user roles.
      if ($property_condition['column'] == 'rolename') {
        // Direct join is faster than a select join.
        $select_query->join('users_roles', 'users_roles' . $key, "users_roles$key.uid = $entity_base_table.uid");
        $select_query->join('role', 'role' . $key, "role$key.rid = users_roles$key.rid AND role$key.name " . EntityFieldQueryExtra_get_op($property_condition) . EntityFieldQueryExtra_get_args($property_condition, $key), EntityFieldQueryExtra_get_args_values($property_condition, $key));
      }
      elseif ($property_condition['column'] == 'rid') {
        // Direct join is faster than a select join.
        $select_query->join('users_roles', 'users_roles' . $key, "users_roles$key.uid = $entity_base_table.uid AND users_roles$key.rid " . EntityFieldQueryExtra_get_op($property_condition) . EntityFieldQueryExtra_get_args($property_condition, $key), EntityFieldQueryExtra_get_args_values($property_condition, $key));
      }
      else {
        $query->addCondition($select_query, "$entity_base_table." . $property_condition['column'], $property_condition);
      }
    }
  }
  if (!empty($query->changeBaseTable)) {
    $query->entity_type = $query->entityConditions['entity_type']['value'];
    unset($query->entityConditions['entity_type']);
    if (isset($query->entityConditions['bundle'])) {
      $query->entityConditions['type'] = $query->entityConditions['bundle'];
      $query->bundle = $query->entityConditions['bundle']['value'];
      unset($query->entityConditions['bundle']);
    }
  }
  foreach ($query->entityConditions as $key => $condition) {
    $query->addCondition($select_query, "$field_base_table.$key", $condition);
  }

  // Order the query.
  foreach ($query->order as $order) {
    if ($order['type'] == 'entity') {
      $key = $order['specifier'];
      $select_query->orderBy("$field_base_table.$key", $order['direction']);
    }
    elseif ($order['type'] == 'field') {
      $specifier = $order['specifier'];
      $field = $specifier['field'];
      $table_alias = $table_aliases[$specifier['index']];
      $sql_field = "$table_alias." . _field_sql_storage_columnname($field['field_name'], $specifier['column']);
      $select_query->orderBy($sql_field, $order['direction']);
    }
    elseif ($order['type'] == 'property') {
      $select_query->orderBy("$entity_base_table." . $order['specifier'], $order['direction']);
    }
  }
  if (!empty($query->changeBaseTable)) {
    $id_key = $base_id;
  }

  return $query->finishQuery($select_query, $id_key);
}

// PDO join condition helper.
function EntityFieldQueryExtra_get_op($property_condition) {
  $operator = $property_condition['operator'];
  $value = $property_condition['value'];
  if (!isset($operator)) {
    if (is_array($value)) {
      $operator = 'IN';
    }
    elseif (!isset($value)) {
      $operator = 'IS NULL';
    }
    else {
      $operator = '=';
    }
  }
  return $operator;
}

// PDO join condition helper.
function EntityFieldQueryExtra_get_args($property_condition, $key) {
  $operator = $property_condition['operator'];
  $value = $property_condition['value'];
  $col = $property_condition['column'];

  $return = '';
  if (is_array($value)) {
    foreach ($value as $k => $v) {
      $return[] = ":efqe_${col}_${key}_${k}";
    }
    $return = "(" . implode(', ', $return) . ")";
  }
  else {
    $return = ":efqe_${col}_${key}";
  }
  return $return;
}

// PDO join condition helper.
function EntityFieldQueryExtra_get_args_values($property_condition, $key) {
  $operator = $property_condition['operator'];
  $value = $property_condition['value'];
  $col = $property_condition['column'];

  $return = array();
  if (is_array($value)) {
    foreach ($value as $k => $v) {
      $return[":efqe_${col}_${key}_${k}"] = $v;
    }
  }
  else {
    $return = array(":efqe_${col}_${key}" => $value);
  }
  return $return;
}

function EntityFieldQueryExtra_entity_create($values, $field_names) {
  $object = new stdClass();
  foreach ($values as $k => $v) {
    if (!array_key_exists($k, $field_names)) {
      $object->{$k} = $v;
    }
  }
  // Put fields in at the bottom of the object.
  foreach ($values as $k => $v) {
    if (!array_key_exists($k, $field_names)) {
      continue;
    }
    if (is_array($v)) {
      foreach ($v as $a => $b) {
        $object->{$field_names[$k][0]}['und'][$a][$field_names[$k][1]] = $b;
      }
    }
    else {
      $object->{$field_names[$k][0]}['und'][0][$field_names[$k][1]] = $v;
    }
  }
  // Remove empty fields.
  EntityFieldQueryExtra_entity_create_kill_null($object, $values, $field_names);

  // unserialize data if it has been serialized.
  if (isset($object->{'data'})) {
    $data = @unserialize($object->{'data'});
    if ($object->{'data'} === 'b:0;' || $data !== FALSE) {
      $object->{'data'} = $data;
    }
  }
  return $object;
}

function EntityFieldQueryExtra_entity_create_kill_null(&$object) {
  foreach ($object as $key => $values) {
    if (!isset($values['und'])) {
      continue;
    }
    $all_null = TRUE;
//     echo httprl_pr($values['und']);
    foreach ($values['und'] as $delta => $data) {
      foreach ($data as $info) {
        if (!is_null($info)) {
          $all_null = FALSE;
          break 2;
        }
      }
    }
    if ($all_null) {
      unset($object->{$key}['und']);
      $object->{$key} = array();
    }
  }
}

class EntityFieldQueryExtra extends EntityFieldQuery {
  // Variables used internally.
  private $addedFields = array();
  private $addedProperties = array();
  private $showQuery = FALSE;
  private $printQuery = FALSE;
  private $EFQpropertyConditions = array();
  private $EFQjoin = array();

  // Variables used internally & externally.
  public $changeBaseTable = FALSE;
  public $executeQuery = TRUE;
  public $entity_type = NULL;
  public $bundle = NULL;
  public $get_user_roles = FALSE;

  public function executeEntityLoad() {
    $results = $this->execute();
    $keys = array(
      'node' => 'nodes',
      'user' => 'users',
    );
    foreach ($keys as $i => $j) {
      // Skip if top level type does not exist.
      if (!isset($results[$i])) {
        continue;
      }
      $eid = array_keys($results[$i]);
      $results[$j] = entity_load($i, $eid);
    }
    return $results;
  }

  public function executeEntityBuildAll() {
    // Get entity and bundle name.
    $entity_type = NULL;
    $bundle_name = NULL;
    if (isset($this->entityConditions['entity_type']['value'])) {
      $entity_type = $this->entityConditions['entity_type']['value'];
      if (isset($this->entityConditions['bundle']['value'])) {
        $bundle_name = $this->entityConditions['bundle']['value'];
      }
    }
    // Get all Properties.
    $entity = entity_get_info($entity_type);
    $properties = $entity['schema_fields_sql']['base table'];
    foreach ($properties as $column) {
      if (!array_key_exists($column, $this->addedProperties)) {
        $this->getPropertyValue($column);
      }
    }

    // Get user roles.
    $this->getPropertyValue('roles');

    // Get all fields.
    $fields_info = field_info_instances($entity_type, $bundle_name);
    $field_output = array();
    if (is_null($bundle_name)) {
      foreach ($fields_info[$entity_type] as $field_name => $value) {
        $field_info = field_info_field($field_name);
        $output = reset($field_info['storage']['details']['sql']['FIELD_LOAD_CURRENT']);
        $field_output[$field_name] = array_keys($output);
      }
    }
    else {
      foreach ($fields_info as $field_name => $value) {
        $field_info = field_info_field($field_name);
        $output = reset($field_info['storage']['details']['sql']['FIELD_LOAD_CURRENT']);
        $field_output[$field_name] = array_keys($output);
      }
    }

    foreach ($field_output as $field_name => $columns) {
      foreach ($columns as $column) {
        if (!array_key_exists($field_name . '_' . $column, $this->addedFields)) {
          $this->getFieldValue($field_name, $column, 'LEFT');
        }
      }
    }

    // Run the query.
    return $this->executeEntityBuild();
  }

  public function executeEntityBuild() {
    $results = $this->execute();
    $keys = array(
      'node' => 'nodes',
      'user' => 'users',
    );
    foreach ($keys as $i => $j) {
      // Skip if top level type does not exist.
      if (!isset($results[$i])) {
        continue;
      }

      $results[$j] = array();
      foreach($results[$i] as $id => $values) {
        $results[$j][$id] = $this->entity_create($values);
      }
    }
    return $results;
  }

  function entity_create($values) {
    $field_names = array();
    foreach ($this->addedFields as $fields) {
      $field_names[$fields['field_name'] . '_' . $fields['column']] = array(
        $fields['field_name'],
        $fields['column'],
      );
    }

    return EntityFieldQueryExtra_entity_create($values, $field_names);
  }

  public function execute() {
    // Sort field arrays so tables added via getFieldValue are joined last.
    if (!empty($this->fields)) {
      // Sort fields so conditional fields show up first.
      ksort($this->fields);
      // If we have no conditions on the fields use our alt callback.
      if (!array_key_exists(0, $this->fields)) {
        $entity_info = entity_get_info($this->entityConditions['entity_type']['value']);
        $base_table = $entity_info['base table'];
        $this->changeBaseTable = $base_table;
        foreach ($this->fields as $index => $field) {
          if (!isset($storage)) {
            $storage = $field['storage']['module'];
          }
          elseif ($storage != $field['storage']['module']) {
            throw new EntityFieldQueryException(t("Can't handle more than one field storage engine"));
          }

          foreach ($this->addedFields as $values) {
            if ($values['index'] == $index && $values['join_type'] == 'INNER') {
              unset($this->fields[$index]);
              // array_unshift while preserving keys.
              $this->fields = array($index => $field) + $this->fields;
              $this->changeBaseTable = FALSE;
            }
          }
        }
        if ($storage != 'field_sql_storage') {
          throw new EntityFieldQueryException(t("Can only handle the field_sql_storage engine"));
        }

        $this->executeCallback = 'EntityFieldQueryExtra_field_sql_storage_field_storage_query';
      }
    }

    if (empty($this->executeCallback)) {
      foreach ($this->propertyConditions as $property_condition) {
        // Handle user role conditions.
        if ($property_condition['column'] == 'rolename' || $property_condition['column'] == 'rid') {
          $this->executeCallback = 'EntityFieldQueryExtra_field_sql_storage_field_storage_query';
          break;
        }
      }
    }

    return parent::execute();
  }

  public function EFQjoin($type, $table, $on, $conditions = array(), $fields = array()) {
    $this->EFQjoin[] = array($type, $table, $on, $conditions, $fields);
    return $this;
  }

  public function EFQpropertyCondition(EntityFieldQueryExtra $efqe_sub, $column) {
    $efqe_sub->executeQuery = FALSE;
    $efqe_sub->executeCallback = 'EntityFieldQueryExtra_field_sql_storage_field_storage_query';
    $this->EFQpropertyConditions[] = array($efqe_sub->execute(), $column);
    $efqe_sub->executeQuery = TRUE;
    $efqe_sub->executeCallback = NULL;

    return $this;
  }

  public function propertyOrderBy($column, $direction = 'ASC', $table = '') {
    $order_array = array(
      'specifier' => $column,
      'direction' => $direction,
    );

    if (empty($table)) {
      $order_array += array(
        'type' => 'property',
      );
    }
    else {
      $order_array += array(
        'type' => 'alt_base_table_property',
        'table' => $table,
      );
    }
    $this->order[] = $order_array;
    return $this;
  }

  /**
   * Add extra field data to the output.
   *
   * @param string $field
   *   Either a field name or a field array.
   * @param string $column
   *   A column defined in the hook_field_schema() of this field. entity_id
   *   and bundle can also be used.
   * @param string $join_type
   *   (optional) What type of join to use. Default is LEFT.
   *
   * @return EntityFieldQuery
   *   The called object.
   */
  public function getFieldValue($field, $column, $join_type = 'LEFT', $base_table = array()) {
    // Add field to the main query.
    if (is_scalar($field)) {
      $field_definition = field_info_field($field);
      if (empty($field_definition)) {
        throw new EntityFieldQueryException(t('Unknown field: @field_name', array('@field_name' => $field)));
      }
      $field = $field_definition;
    }

    // Save the index used for the new field, for later use in field storage.
    $index = $this->saveFieldIndex($field);

    // Save data needed in the finishQuery() method.
    $added_fields = array(
      'field_name' => $field['field_name'],
      'column' => $column,
      'index' => $index,
      'join_type' => $join_type,
      'base_table' => $base_table,
      'field' => $field,
    );
    $this->addedFields[$field['field_name'] . '_' . $column] = $added_fields;
    return $this;
  }

  /**
   * Add extra property data to the output.
   *
   * @param string $column
   *   A column defined in the hook_field_schema() of the entity.
   *
   * @return EntityFieldQuery
   *   The called object.
   */
  public function getPropertyValue($column, $base_table = '') {
    // Save data needed in the finishQuery() method.
    $this->addedProperties[$column.$base_table] = array(
      $column,
      $base_table,
    );
    return $this;
  }

  /**
   * Add the query that was ran to the returned object under the #query key.
   *
   * @param bool $bool
   *   Set to TRUE to see the query being ran.
   *
   * @return EntityFieldQuery
   *   The called object.
   */
  public function showQuery($bool = TRUE) {
    // Save data needed in the finishQuery() method.
    $this->showQuery = $bool;
    return $this;
  }

  /**
   * Print out the query that is going to ran.
   *
   * @param bool $bool
   *   Set to TRUE to print out the query being ran.
   *
   * @return EntityFieldQuery
   *   The called object.
   */
  public function printQuery($bool = TRUE) {
    // Save data needed in the finishQuery() method.
    $this->printQuery = $bool;
    return $this;
  }

  /**
   * Finishes the query.
   *
   * Adds tags, meta data, range and returns the requested list or count.
   *
   * @param SelectQuery $select_query
   *   A SelectQuery which has entity_type, entity_id, revision_id and bundle
   *   fields added.
   * @param string $id_key
   *   Which field's values to use as the returned array keys.
   *
   * @return
   *   See EntityFieldQuery::execute().
   */
  function finishQuery($select_query, $id_key = 'entity_id') {
    $columns = $this->_prep_final_query($select_query, $id_key);
    if ($this->executeQuery) {
      return $this->_execute_final_query($select_query, $id_key, $columns);
    }
    else {
      return $select_query;
    }
  }

  /**
   * Check if the field already has a table that does a join.
   *
   * @param array $field
   *   field array from field_info_field().
   *
   * @return int
   *   key position in $this->fields array.
   */
  private function saveFieldIndex($field) {
    $fields = $this->fields;
    foreach ($fields as $index => $field_info) {
      if (isset($field_info['field_name']) && $field_info['field_name'] == $field['field_name']) {
        return $index;
      }
    }
    // Add these tables in after conditions.
    $index = 100;
    if (isset($field['storage'])) {
      $index += count($this->fields);
      $this->fields[$index] = $field;
    }
    return $index;
  }

  private function _prep_final_query($select_query, $id_key = 'entity_id') {
    // Do nested condition.
    if (!empty($this->EFQpropertyConditions)) {
      foreach ($this->EFQpropertyConditions as $values) {
        $select_query->condition("node.$values[1]", $values[0], 'IN');
      }
    }

    // Do EFQ join.
    if (!empty($this->EFQjoin)) {
      // Get base table for join.
      $tables =& $select_query->getTables();
      $base_table = '';
      foreach ($tables as &$t) {
        if (is_null($t['join type']) && is_null($t['condition'])) {
          $base_table = $t['alias'];
          break;
        }
      }
      foreach ($this->EFQjoin as $k => $values) {
        // Set initial values.
        list($type, $table, $on, $conditions, $fields) = $values;
        $table_alias = $table . $k;

        // Get row from base table to join on.
        $row = $on;
        if (empty($this->changeBaseTable)) {
          $row = $id_key;
        }

        // Build conditions and arguments.
        $condition = "$table_alias.$on = $base_table.$row";
        $arguments = array();
        if (!empty($conditions)) {
          foreach ($conditions as $i => $join_condition) {
            $property_condition['column'] = $join_condition[0];
            $property_condition['value'] = $join_condition[1];
            $property_condition['operator'] = isset($join_condition[2]) ? $join_condition[2] : NULL;
            $key = "${k}_${i}";
            $condition .= " AND $table_alias.$join_condition[0] " . EntityFieldQueryExtra_get_op($property_condition) . ' ' . EntityFieldQueryExtra_get_args($property_condition, $key);
            $arguments += EntityFieldQueryExtra_get_args_values($property_condition, $key);
          }
        }
        $select_query->addJoin($type, $table, $table_alias, $condition, $arguments);

        // Add in fields.
        if (!empty($fields)) {
          foreach ($fields as $field => $field_alias) {
            $select_query->addField($table_alias, $field, $field_alias);
          }
        }
      }
    }

    // Iterate through all fields. If the query is trying to fetch results
    // where a field is null, then alter the query to use a LEFT OUTER join.
    // Otherwise the query will always return 0 results.
    foreach ($this->fieldConditions as $key => $fieldCondition) {
      if ($fieldCondition['operator'] == 'IS NULL' && isset($this->fields[$key]['storage']['details']['sql'][FIELD_LOAD_CURRENT])) {
        $tables =& $select_query->getTables();
        foreach ($tables as &$table) {
          $keys = array_keys($this->fields[$key]['storage']['details']['sql'][FIELD_LOAD_CURRENT]);
          $sql_table = reset($keys);
          if ($table['table'] == $sql_table) {
            $table['join type'] = 'LEFT OUTER';
          }
        }
      }
    }

    // Same as EntityFieldQuery::execute()
    foreach ($this->tags as $tag) {
      $select_query->addTag($tag);
    }
    foreach ($this->metaData as $key => $object) {
      $select_query->addMetaData($key, $object);
    }
    $select_query->addMetaData('entity_field_query', $this);
    if ($this->range) {
      $select_query->range($this->range['start'], $this->range['length']);
    }
    if ($this->count) {
      return $select_query->countQuery()->execute()->fetchField();
    }

    // Change join condition if base table is changing.
    $columns = array();
    foreach($this->addedFields as $addedField) {
      if (empty($addedField['base_table'])) {
        continue;
      }
      $sql_table = key($addedField['field']['storage']['details']['sql']['FIELD_LOAD_CURRENT']);
      $tables =& $select_query->getTables();
      $base_table_col = reset($addedField['base_table']);
      $base_table_alias = key($addedField['base_table']);
      $counter_a = 0;
      foreach ($tables as &$table) {
        $counter_a++;
        if ($table['table'] == $base_table_alias) {
          $base_table_alias = $table['alias'];
          break;
        }
      }
      $counter_b = 0;
      $moved_tables = array();
      foreach ($tables as $k => &$table) {
        $counter_b++;
        if ($table['table'] != $sql_table) {
          continue;
        }
        $table_alias = $table['alias'];
        $table['condition'] = "$base_table_alias.$base_table_col = $table_alias.$id_key";
        if ($counter_a > $counter_b) {
          $moved_tables[$k] = $table;
          unset($tables[$k]);
        }
      }
      $tables += $moved_tables;
    }

    // Get field value.
    foreach($this->addedFields as $addedField) {
      $fields = $select_query->getFields();
      if (!empty($addedField['field_name'])) {
        // Add field to query.
        $column = $addedField['field_name'] . '_' . $addedField['column'];
        $table_name = 'field_data_' . $addedField['field_name'] . $addedField['index'];
        $select_query->addField($table_name, $column);

        // Change join type if requested to do so.
        if (!empty($addedField['join_type'])) {
          $tables =& $select_query->getTables();
          foreach ($tables as &$table) {
            if ($table['alias'] == $table_name && !is_null($table['join type'])) {
              $table['join type'] = $addedField['join_type'];
            }
          }
        }
      }
      else {
        $column = $addedField['column'];
        $select_query->addField($fields['entity_id']['table'], $column);
      }
      $columns[] = $column;
    }

    // Get property value.
    if (!empty($this->addedProperties)) {
      // Get the entity base table.
      if (isset($this->entityConditions['entity_type']['value'])) {
        $entity_info = entity_get_info($this->entityConditions['entity_type']['value']);
        $base_table = $entity_info['base table'];
      }
      else {
        $base_table = $this->changeBaseTable;
      }
      foreach($this->addedProperties as $key => $column) {
        if ($column[0] == 'roles') {
          // Special case for user roles.
          $role_alias = 'role_' . $key;
          $users_role_alias = 'users_roles_' . $key;
          $users_role_alias_found = FALSE;
          $role_alias_found = FALSE;

          // Reuse tables if possible.
          $tables =& $select_query->getTables();
          foreach ($tables as &$table) {
            if ($table['table'] == 'users_roles') {
              $users_role_alias = $table['alias'];
              $users_role_alias_found = TRUE;
            }
            if ($table['table'] == 'role') {
              $role_alias = $table['alias'];
              $role_alias_found = TRUE;
            }
          }
          if (empty($users_role_alias_found)) {
            $select_query->join('users_roles', $users_role_alias, "$users_role_alias.uid = $base_table.uid");
          }
          if (empty($role_alias_found)) {
            $select_query->join('role', $role_alias, "$role_alias.rid = $users_role_alias.rid");
          }

          // Get role field info.
          $select_query->addField($role_alias, 'name', 'role_names');
          $select_query->addField($role_alias, 'rid', 'role_rids');
        }
        else {
          // Add property to query.
          if (empty($column[1])) {
            $select_query->addField($base_table, $column[0]);
            $columns[] = $column[0];
          }
          else {
            // Reuse tables if possible.
            $tables =& $select_query->getTables();
            $temp_base_table = $column[1];
            foreach ($tables as &$table) {
              if ($table['table'] == $column[1]) {
                $temp_base_table = $table['alias'];
                $temp_base_table_found = TRUE;
              }
            }
            if (empty($temp_base_table_found)) {
              if ($column[1] == 'users') {
                $id = 'uid';
              }
              if ($column[1] == 'node') {
                $id = 'nid';
              }
              $select_query->join($temp_base_table, $temp_base_table, "$temp_base_table.$id = $base_table.$id");
            }
            $select_query->addField($temp_base_table, $column[0], $column[1] . '_' . $column[0]);
            $columns[] = $column[1] . '_' . $column[0];
          }
        }
      }
    }

    // Adjust order.
    if (!empty($this->order)) {
      foreach ($this->order as $order) {
        if ($order['type'] == 'alt_base_table_property') {
          $select_query->orderBy($order['table'] . '.' . $order['specifier'], $order['direction']);
        }
      }
    }

    // Add in query debugging if needed.
    if ($this->printQuery) {
      print($this->_get_query_string($select_query));
    }
    return $columns;
  }

  private function _execute_final_query($select_query, $id_key = 'entity_id', $columns = array()) {
    $return = array();
    if ($this->showQuery) {
      $return['#query'] = $this->_get_query_string($select_query);
    }

    // Run the query and iterate over each result returned.
    foreach ($select_query->execute() as $partial_entity) {
      $bundle = isset($partial_entity->bundle) ? $partial_entity->bundle : $this->bundle;
      $entity_type = isset($partial_entity->entity_type) ? $partial_entity->entity_type : $this->entity_type;
      $partial_entity->entity_id = isset($partial_entity->entity_id) ? $partial_entity->entity_id : $partial_entity->$id_key;
      $revision_id = isset($partial_entity->revision_id) ? $partial_entity->revision_id : NULL;
      $entity = entity_create_stub_entity($entity_type, array($partial_entity->entity_id, $revision_id, $bundle));
      // Add in the additional fields to the entity stub.
      foreach ($partial_entity as $key => $value) {
        $entity->{$key} = $value;
      }
      foreach ($columns as $column_name) {
        if (!isset($partial_entity->{$column_name})) {
          $entity->{$column_name} = NULL;
        }
      }
      if (!isset($return[$entity_type][$partial_entity->$id_key])) {
        $return[$entity_type][$partial_entity->$id_key] = $entity;
      }
      else {
        // Handle multiple delta values.
        foreach ($entity as $k => $v) {
          // Special case roles.
          if ($k == 'roles' && is_null($v)) {
            continue;
          }
          if ($return[$entity_type][$partial_entity->$id_key]->$k != $v) {
            if (!is_array($return[$entity_type][$partial_entity->$id_key]->$k)) {
              $temp = $return[$entity_type][$partial_entity->$id_key]->$k;
              unset($return[$entity_type][$partial_entity->$id_key]->$k);
              $return[$entity_type][$partial_entity->$id_key]->{$k} = array($temp);
            }
            $return[$entity_type][$partial_entity->$id_key]->{$k}[] = $v;
          }
        }
      }
      // Handle roles.
      if (isset($this->addedProperties['roles'])) {
        // Add in core default roles.
        if (isset($return[$entity_type][$partial_entity->$id_key]->{'uid'})) {
          if ($return[$entity_type][$partial_entity->$id_key]->{'uid'}) {
            $return[$entity_type][$partial_entity->$id_key]->{'roles'}[DRUPAL_AUTHENTICATED_RID] = 'authenticated user';
          }
          else {
            $return[$entity_type][$partial_entity->$id_key]->{'role_names'}[DRUPAL_ANONYMOUS_RID] = 'anonymous user';
          }
        }

        // Add in set roles.
        if (!empty($return[$entity_type][$partial_entity->$id_key]->{'role_names'}) && !empty($return[$entity_type][$partial_entity->$id_key]->{'role_rids'})) {
          if (!is_array($return[$entity_type][$partial_entity->$id_key]->{'role_rids'})) {
            $return[$entity_type][$partial_entity->$id_key]->{'roles'}[$return[$entity_type][$partial_entity->$id_key]->{'role_rids'}] = $return[$entity_type][$partial_entity->$id_key]->{'role_names'};
          }
          else {
            foreach ($return[$entity_type][$partial_entity->$id_key]->{'role_rids'} as $k => $v) {
              $return[$entity_type][$partial_entity->$id_key]->{'roles'}[$v] = $return[$entity_type][$partial_entity->$id_key]->{'role_names'}[$k];
            }
          }
        }
      }
      $this->ordered_results[] = $partial_entity;
    }
    return $return;
  }

  /**
   * Return back a string of the query that is going to be ran.
   *
   * @param object $query
   *   SelectQueryInterface object.
   *
   * @return string
   *   Formatted query string.
   */
  private function _get_query_string(SelectQueryInterface $query) {
    $string = (string) $query;
    $arguments = $query->arguments();

    // Convert to regular SQL Syntax
    if (!empty($arguments) && is_array($arguments)) {
      foreach ($arguments as $placeholder => &$value) {
        if (is_string($value)) {
          $value = "'$value'";
        }
      }
      $string = strtr($string, $arguments);
      $string = str_replace(array(' {', '} ', "\n{", "}\n"), ' ', $string);
    }
    // Pretty print SQL.
    if (!class_exists('SqlFormatter')) {
      // Make the SqlFormatter class available.
      module_load_include('php', 'entityfieldqueryextra', 'sql_formatter/SqlFormatter');
    }
    if (!class_exists('SqlFormatter')) {
      $string = str_replace(', ', ",\n  ", $string);
      $string = str_replace(' AND ', "\n  AND ", $string);
    }
    else {
      $string = SqlFormatter::format($string, false) . "\n\n";
    }
    $string = str_replace(' ON ', "\n  ON ", $string);

    return $string;
  }
}
