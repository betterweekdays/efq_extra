<?php

/**
 * Implements hook_field_storage_query().
 */
function EntityFieldQueryExtra_field_sql_storage_field_storage_query(EntityFieldQuery $query) {
  if ($query->age == FIELD_LOAD_CURRENT) {
    $tablename_function = '_field_sql_storage_tablename';
    $id_key = 'entity_id';
  }
  else {
    $tablename_function = '_field_sql_storage_revision_tablename';
    $id_key = 'revision_id';
  }
  $table_aliases = array();
  // Use base table if no conditions and only left joins.
  $first = TRUE;
  if (!empty($query->changeBaseTable)) {
    $select_query = db_select($query->changeBaseTable, $query->changeBaseTable);
    $field_base_table = $query->changeBaseTable;
    $first = FALSE;
    if ($field_base_table == 'node') {
      $base_id = 'nid';
    }
    if ($field_base_table == 'users') {
      $base_id = 'uid';
    }
    $select_query->addField($field_base_table, $base_id);
  }
  // Add tables for the fields used.
  $second_table_alias = FALSE;
  foreach ($query->fields as $key => $field) {
    $tablename = $tablename_function($field);
    // Every field needs a new table.
    $table_alias = $tablename . $key;
    $table_aliases[$key] = $table_alias;
    if (!$first) {
      if (!empty($query->changeBaseTable)) {
        $select_query->join($tablename, $table_alias, "$table_alias.$id_key = $field_base_table.$base_id");
      }
      else {
        $select_query->join($tablename, $table_alias, "$table_alias.entity_type = $field_base_table.entity_type AND $table_alias.$id_key = $field_base_table.$id_key");
      }
      if (empty($second_table_alias)) {
        $second_table_alias = $field_base_table;
      }
    }
    else {
      $select_query = db_select($tablename, $table_alias);
      // Allow queries internal to the Field API to opt out of the access
      // check, for situations where the query's results should not depend on
      // the access grants for the current user.
      if (!isset($query->tags['DANGEROUS_ACCESS_CHECK_OPT_OUT'])) {
        $select_query->addTag('entity_field_access');
      }
      $select_query->addMetaData('base_table', $tablename);
      $select_query->fields($table_alias, array('entity_type', 'entity_id', 'revision_id', 'bundle'));
      $field_base_table = $table_alias;
      $first = FALSE;
    }
    if ($field['cardinality'] != 1 || $field['translatable']) {
      $select_query->distinct();
    }
  }
  if (empty($second_table_alias)) {
    $second_table_alias = $table_alias;
  }

  // Add field conditions. We need a fresh grouping cache.
  drupal_static_reset('_field_sql_storage_query_field_conditions');
  _field_sql_storage_query_field_conditions($query, $select_query, $query->fieldConditions, $table_aliases, '_field_sql_storage_columnname');

  // Add field meta conditions.
  _field_sql_storage_query_field_conditions($query, $select_query, $query->fieldMetaConditions, $table_aliases, '_field_sql_storage_query_columnname');

  if (isset($query->deleted) && empty($query->changeBaseTable)) {
    $select_query->condition("$second_table_alias.deleted", (int) $query->deleted);
  }

  // Is there a need to sort the query by property?
  $has_property_order = FALSE;
  foreach ($query->order as $order) {
    if ($order['type'] == 'property') {
      $has_property_order = TRUE;
    }
  }

  if ($query->propertyConditions || $has_property_order) {
    if (empty($query->entityConditions['entity_type']['value'])) {
      throw new EntityFieldQueryException('Property conditions and orders must have an entity type defined.');
    }
    $entity_type = $query->entityConditions['entity_type']['value'];
    if (empty($query->changeBaseTable)) {
      $entity_base_table = _field_sql_storage_query_join_entity($select_query, $entity_type, $field_base_table);
    }
    else {
      $entity_base_table = $query->changeBaseTable;
    }
    $query->entityConditions['entity_type']['operator'] = '=';
    foreach ($query->propertyConditions as $key => $property_condition) {
      // Handle user roles.
      if ($property_condition['column'] == 'rolename') {
        // Direct join is faster than a select join.
        $select_query->join('users_roles', 'users_roles' . $key, "users_roles$key.uid = $entity_base_table.uid");
        $select_query->join('role', 'role' . $key, "role$key.rid = users_roles$key.rid AND role$key.name " . EntityFieldQueryExtra_get_op($property_condition) . EntityFieldQueryExtra_get_args($property_condition, $key), EntityFieldQueryExtra_get_args_values($property_condition, $key));
      }
      elseif ($property_condition['column'] == 'rid') {
        // Direct join is faster than a select join.
        $select_query->join('users_roles', 'users_roles' . $key, "users_roles$key.uid = $entity_base_table.uid AND users_roles$key.rid " . EntityFieldQueryExtra_get_op($property_condition) . EntityFieldQueryExtra_get_args($property_condition, $key), EntityFieldQueryExtra_get_args_values($property_condition, $key));
      }
      else {
        $query->addCondition($select_query, "$entity_base_table." . $property_condition['column'], $property_condition);
      }
    }
  }
  if (!empty($query->changeBaseTable)) {
    $query->entity_type = $query->entityConditions['entity_type']['value'];
    unset($query->entityConditions['entity_type']);
    if (isset($query->entityConditions['bundle'])) {
      $query->entityConditions['type'] = $query->entityConditions['bundle'];
      $query->bundle = $query->entityConditions['bundle']['value'];
      unset($query->entityConditions['bundle']);
    }
  }
  foreach ($query->entityConditions as $key => $condition) {
    $query->addCondition($select_query, "$field_base_table.$key", $condition);
  }

  // Order the query.
  foreach ($query->order as $order) {
    if ($order['type'] == 'entity') {
      $key = $order['specifier'];
      $select_query->orderBy("$field_base_table.$key", $order['direction']);
    }
    elseif ($order['type'] == 'field') {
      $specifier = $order['specifier'];
      $field = $specifier['field'];
      $table_alias = $table_aliases[$specifier['index']];
      $sql_field = "$table_alias." . _field_sql_storage_columnname($field['field_name'], $specifier['column']);
      $select_query->orderBy($sql_field, $order['direction']);
    }
    elseif ($order['type'] == 'property') {
      $select_query->orderBy("$entity_base_table." . $order['specifier'], $order['direction']);
    }
  }
  if (!empty($query->changeBaseTable)) {
    $id_key = $base_id;
  }

  return $query->finishQuery($select_query, $id_key);
}

// PDO join condition helper.
function EntityFieldQueryExtra_get_op($property_condition) {
  $operator = $property_condition['operator'];
  $value = $property_condition['value'];
  if (!isset($operator)) {
    if (is_array($value)) {
      $operator = 'IN';
    }
    elseif (!isset($value)) {
      $operator = 'IS NULL';
    }
    else {
      $operator = '=';
    }
  }
  return $operator;
}

// PDO join condition helper.
function EntityFieldQueryExtra_get_args($property_condition, $key) {
  $operator = $property_condition['operator'];
  $value = $property_condition['value'];
  $col = $property_condition['column'];

  $return = '';
  if (is_array($value)) {
    foreach ($value as $k => $v) {
      $return[] = ":efqe_${col}_${key}_${k}";
    }
    $return = "(" . implode(', ', $return) . ")";
  }
  else {
    $return = ":efqe_${col}_${key}";
  }
  return $return;
}

// PDO join condition helper.
function EntityFieldQueryExtra_get_args_values($property_condition, $key) {
  $operator = $property_condition['operator'];
  $value = $property_condition['value'];
  $col = $property_condition['column'];

  $return = array();
  if (is_array($value)) {
    foreach ($value as $k => $v) {
      $return[":efqe_${col}_${key}_${k}"] = $v;
    }
  }
  else {
    $return = array(":efqe_${col}_${key}" => $value);
  }
  return $return;
}

class EntityFieldQueryExtra extends EntityFieldQuery {
  // Extra added fields to the query
  private $addedFields = array();
  private $addedProperties = array();
  private $showQuery = FALSE;
  public $changeBaseTable = FALSE;
  public $entity_type = NULL;
  public $bundle = NULL;

  public function executeEntityLoad() {
    $results = $this->execute();
    $keys = array(
      'node' => 'nodes',
      'user' => 'users',
    );
    foreach ($keys as $i => $j) {
      // Skip if top level type does not exist.
      if (!isset($results[$i])) {
        continue;
      }
      $eid = array_keys($results[$i]);
      $results[$j] = entity_load($i, $eid);
    }
    return $results;
  }

  public function executeEntityBuild() {
    $results = $this->execute();
    $keys = array(
      'node' => 'nodes',
      'user' => 'users',
    );
    $field_names = array();
    foreach ($this->addedFields as $fields) {
      $field_names[$fields['field_name'] . '_' . $fields['column']] = array(
        $fields['field_name'],
        $fields['column'],
      );
    }

    foreach ($keys as $i => $j) {
      // Skip if top level type does not exist.
      if (!isset($results[$i])) {
        continue;
      }

      $results[$j] = array();
      foreach($results[$i] as $nid => $values) {
        $results[$j][$nid] = new stdClass();
        foreach ($values as $k => $v) {
          if (!array_key_exists($k, $field_names)) {
            $results[$j][$nid]->{$k} = $v;
          }
        }
        // Put fields in at the bottom of the object.
        foreach ($values as $k => $v) {
          if (array_key_exists($k, $field_names)) {
            if (is_array($v)) {
              foreach ($v as $a => $b) {
                $results[$j][$nid]->{$field_names[$k][0]}['und'][$a][$field_names[$k][1]] = $b;
              }
            }
            else {
              if (is_null($v)) {
                $results[$j][$nid]->{$field_names[$k][0]} = array();
              }
              else {
                $results[$j][$nid]->{$field_names[$k][0]}['und'][0][$field_names[$k][1]] = $v;
              }
            }
          }
        }
      }
    }
    return $results;
  }

  public function execute() {
    // Sort field arrays so tables added via getFieldValue are joined last.
    if (!empty($this->fields)) {
      ksort($this->fields);
      // If we have no conditions on the fields use our alt callback.
      if (!array_key_exists(0, $this->fields)) {
        $entity_info = entity_get_info($this->entityConditions['entity_type']['value']);
        $base_table = $entity_info['base table'];
        $this->changeBaseTable = $base_table;
        foreach ($this->fields as $index => $field) {
          if (!isset($storage)) {
            $storage = $field['storage']['module'];
          }
          elseif ($storage != $field['storage']['module']) {
            throw new EntityFieldQueryException(t("Can't handle more than one field storage engine"));
          }

          foreach ($this->addedFields as $values) {
            if ($values['index'] == $index && $values['join_type'] == 'INNER') {
              unset($this->fields[$index]);
              // array_unshift while preserving keys.
              $this->fields = array($index => $field) + $this->fields;
              $this->changeBaseTable = FALSE;
            }
          }
        }
        if ($storage != 'field_sql_storage') {
          throw new EntityFieldQueryException(t("Can only handle the field_sql_storage engine"));
        }

        $this->executeCallback = 'EntityFieldQueryExtra_field_sql_storage_field_storage_query';
      }
    }

    if (empty($this->executeCallback)) {
      foreach ($this->propertyConditions as $property_condition) {
        // Handle user roles.
        if ($property_condition['column'] == 'rolename' || $property_condition['column'] == 'rid') {
          $this->executeCallback = 'EntityFieldQueryExtra_field_sql_storage_field_storage_query';
          break;
        }
      }
    }

    return parent::execute();
  }

  /**
   * Finishes the query.
   *
   * Adds tags, metaData, range and returns the requested list or count.
   *
   * @param SelectQuery $select_query
   *   A SelectQuery which has entity_type, entity_id, revision_id and bundle
   *   fields added.
   * @param string $id_key
   *   Which field's values to use as the returned array keys.
   *
   * @return
   *   See EntityFieldQuery::execute().
   */
  function finishQuery($select_query, $id_key = 'entity_id') {
    // Iterate through all fields. If the query is trying to fetch results
    // where a field is null, then alter the query to use a LEFT OUTER join.
    // Otherwise the query will always return 0 results.
    foreach ($this->fieldConditions as $key => $fieldCondition) {
      if ($fieldCondition['operator'] == 'IS NULL' && isset($this->fields[$key]['storage']['details']['sql'][FIELD_LOAD_CURRENT])) {
        $tables =& $select_query->getTables();
        foreach ($tables as &$table) {
          $keys = array_keys($this->fields[$key]['storage']['details']['sql'][FIELD_LOAD_CURRENT]);
          $sql_table = reset($keys);
          if ($table['table'] == $sql_table) {
            $table['join type'] = 'LEFT OUTER';
          }
        }
      }
    }

    // Same as EntityFieldQuery::execute()
    foreach ($this->tags as $tag) {
      $select_query->addTag($tag);
    }
    foreach ($this->metaData as $key => $object) {
      $select_query->addMetaData($key, $object);
    }
    $select_query->addMetaData('entity_field_query', $this);
    if ($this->range) {
      $select_query->range($this->range['start'], $this->range['length']);
    }
    if ($this->count) {
      return $select_query->countQuery()->execute()->fetchField();
    }

    // Our modifed code.
    $columns = array();
    foreach($this->addedFields as $addedField) {
      $fields = $select_query->getFields();
      if (!empty($addedField['field_name'])) {
        // Add field to query.
        $column = $addedField['field_name'] . '_' . $addedField['column'];
        $table_name = 'field_data_' . $addedField['field_name'] . $addedField['index'];
        $select_query->addField($table_name, $column);

        // Change join type if requested to do so.
        if (!empty($addedField['join_type'])) {
          $tables =& $select_query->getTables();
          foreach ($tables as &$table) {
            if ($table['alias'] == $table_name && !is_null($table['join type'])) {
              $table['join type'] = $addedField['join_type'];
            }
          }
        }
      }
      else {
        $column = $addedField['column'];
        $select_query->addField($fields['entity_id']['table'], $column);
      }
      $columns[] = $column;
    }
    if (!empty($this->addedProperties)) {
      // Get the entity base table.
      if (isset($this->entityConditions['entity_type']['value'])) {
        $entity_info = entity_get_info($this->entityConditions['entity_type']['value']);
        $base_table = $entity_info['base table'];
      }
      else {
        $base_table = $this->changeBaseTable;
      }
      foreach($this->addedProperties as $column) {
        // Add property to query.
        $select_query->addField($base_table, $column);
        $columns[] = $column;
      }
    }

    $return = array();
    if ($this->showQuery) {
      $return['#query'] = $this->_get_query_string($select_query);
    }

    foreach ($select_query->execute() as $partial_entity) {
      $bundle = isset($partial_entity->bundle) ? $partial_entity->bundle : $this->bundle;
      $entity_type = isset($partial_entity->entity_type) ? $partial_entity->entity_type : $this->entity_type;
      $partial_entity->entity_id = isset($partial_entity->entity_id) ? $partial_entity->entity_id : $partial_entity->$id_key;
      $revision_id = isset($partial_entity->revision_id) ? $partial_entity->revision_id : NULL;
      $entity = entity_create_stub_entity($entity_type, array($partial_entity->entity_id, $revision_id, $bundle));
      // Add in the additional fields to the entity stub.
      foreach ($partial_entity as $key => $value) {
        $entity->{$key} = $value;
      }
      foreach ($columns as $column_name) {
        if (!isset($partial_entity->{$column_name})) {
          $entity->{$column_name} = NULL;
        }
      }
      if (!isset($return[$entity_type][$partial_entity->$id_key])) {
        $return[$entity_type][$partial_entity->$id_key] = $entity;
      }
      else {
        // Handle mutiple delta values.
        foreach ($entity as $k => $v) {
          if ($return[$entity_type][$partial_entity->$id_key]->$k != $v) {
            if (!is_array($return[$entity_type][$partial_entity->$id_key]->$k)) {
              $temp = $return[$entity_type][$partial_entity->$id_key]->$k;
              unset($return[$entity_type][$partial_entity->$id_key]->$k);
              $return[$entity_type][$partial_entity->$id_key]->{$k} = array($temp);
            }
            $return[$entity_type][$partial_entity->$id_key]->{$k}[] = $v;
          }
        }
      }
      $this->ordered_results[] = $partial_entity;
    }
    return $return;
  }

  /**
   * Add extra field data to the output.
   *
   * @param string $field
   *   Either a field name or a field array.
   * @param string $column
   *   A column defined in the hook_field_schema() of this field. entity_id
   *   and bundle can also be used.
   * @param string $join_type
   *   (optional) What type of join to use. Default is LEFT.
   *
   * @return EntityFieldQuery
   *   The called object.
   */
  public function getFieldValue($field, $column, $join_type = 'LEFT') {
    // Add field to the main query.
    if (is_scalar($field)) {
      $field_definition = field_info_field($field);
      if (empty($field_definition)) {
        throw new EntityFieldQueryException(t('Unknown field: @field_name', array('@field_name' => $field)));
      }
      $field = $field_definition;
    }

    // Save the index used for the new field, for later use in field storage.
    $index = $this->saveFieldIndex($field);

    // Save data needed in the finishQuery() method.
    $added_fields = array(
      'field_name' => $field['field_name'],
      'column' => $column,
      'index' => $index,
      'join_type' => $join_type,
    );
    $this->addedFields[] = $added_fields;
    return $this;
  }

  /**
   * Add extra property data to the output.
   *
   * @param string $column
   *   A column defined in the hook_field_schema() of the entity.
   *
   * @return EntityFieldQuery
   *   The called object.
   */
  public function getPropertyValue($column) {
    // Save data needed in the finishQuery() method.
    $this->addedProperties[] = $column;
    return $this;
  }


  /**
   * Add extra property data to the output.
   *
   * @param bool $bool
   *   Set to TRUE to see the query being ran.
   *
   * @return EntityFieldQuery
   *   The called object.
   */
  public function showQuery($bool = TRUE) {
    // Save data needed in the finishQuery() method.
    $this->showQuery = $bool;
    return $this;
  }

  /**
   * Check if the field already has a table that does a join.
   *
   * @param array $field
   *   field array from field_info_field().
   *
   * @return int
   *   key position in $this->fields array.
   */
  private function saveFieldIndex($field) {
    $fields = $this->fields;
    foreach ($fields as $index => $field_info) {
      if (isset($field_info['field_name']) && $field_info['field_name'] == $field['field_name']) {
        return $index;
      }
    }
    // Add these tables in after conditions.
    $index = 100;
    if (isset($field['storage'])) {
      $index += count($this->fields);
      $this->fields[$index] = $field;
    }
    return $index;
  }

  private function _get_query_string(SelectQueryInterface $query) {
    $string = (string) $query;
    $arguments = $query->arguments();

    // Convert to regular SQL Syntax
    if (!empty($arguments) && is_array($arguments)) {
      foreach ($arguments as $placeholder => &$value) {
        if (is_string($value)) {
          $value = "'$value'";
        }
      }
      $string = strtr($string, $arguments);
      $string = str_replace(array('{', '}'), '', $string);
    }
    // Pretty print SQL.
    if (!class_exists('SqlFormatter')) {
      // Make the SqlFormatter class available.
      module_load_include('php', 'entityfieldqueryextra', 'sql_formatter/SqlFormatter');
    }
    if (!class_exists('SqlFormatter')) {
      $string = str_replace(', ', ",\n  ", $string);
      $string = str_replace(' ON ', "\n  ON ", $string);
      $string = str_replace(' AND ', "\n  AND ", $string);
    }
    else {
      $string = SqlFormatter::format($string, false) . "\n\n";
    }

    return $string;
  }
}