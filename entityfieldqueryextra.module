<?php

/**
 * Implements hook_entity_info_alter().
 */
function EntityFieldQueryExtra_entity_info_alter(&$entity_info) {
  // Add in missing info for comments.
  if (!empty($entity_info['comment']) && empty($entity_info['comment']['bundle keys']['bundle'])) {
    $entity_info['comment']['bundle keys']['bundle'] = 'type';
  }
}

/**
 * Implements hook_field_views_data_alter().
 */
function EntityFieldQueryExtra_field_views_data_alter(&$result, $field, $module) {
  foreach ($result as $key => &$values) {
    if (isset($values[$field['field_name']]['field']['handler']) && $values[$field['field_name']]['field']['handler'] == 'views_handler_field_field') {
      $values[$field['field_name']]['field']['handler'] = 'EntityFieldQueryExtra_views_handler_field_field';
    }
  }
}

/**
 * EFQE Alt to entity_load_multiple().
 *
 * @param string $entity_type
 *   The entity type to load, e.g. node or user.
 * @param array $ids
 *   An array of entity IDs, or FALSE to load all entities.
 *
 * @return array
 *   An array of entity objects indexed by their ids. When no results are found,
 *   an empty array is returned.
 */
function EntityFieldQueryExtra_entity_load_multiple($entity_type, $ids) {
  $query = new EntityFieldQueryExtra();
  $entity_lut = EFQE_entity_lut($entity_type);

  $query
    ->entityCondition('entity_type', $entity_lut['type'])
    ->propertyCondition($entity_lut['id'], $ids)
    ->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
  $results = $query->executeEntityBuildAll();
  $entities = $results[$entity_lut['name']];
  return $entities;
}

/**
 * A field that displays fieldapi fields.
 *
 * @ingroup views_field_handlers
 */
class EntityFieldQueryExtra_views_handler_field_field extends views_handler_field_field {
  /**
   * Load the entities for all fields that are about to be displayed.
   */
  function post_execute(&$values) {
    // Uncomment this line to disable EFQE Views.
//     return views_handler_field_field::post_execute($values);

    // Do nothing if $values is empty
    if (empty($values)) {
      return;
    }

    // Divide the entity ids by entity type, so they can be loaded in bulk.
    $entities_by_type = array();
    $revisions_by_type = array();
    $fields_by_type = array();
    foreach ($values as $key => $object) {
      if (   !isset($this->aliases['entity_type'])
          || !isset($object->{$this->aliases['entity_type']})
          || !isset($object->{$this->field_alias})
          || isset($values[$key]->_field_data[$this->field_alias])
          ) {
        continue;
      }

      $entity_type = $object->{$this->aliases['entity_type']};
      if (empty($this->definition['is revision'])) {
        $entity_id = $object->{$this->field_alias};
        $entities_by_type[$entity_type][$key] = $entity_id;
      }
      else {
        $revision_id = $object->{$this->field_alias};
        $entity_id = $object->{$this->aliases['entity_id']};
        $entities_by_type[$entity_type][$key] = array($entity_id, $revision_id);
      }
      foreach ($object as $row_id => $value) {
        if (strpos($row_id, 'field_data_') === FALSE) {
          continue;
        }
        $pos = strrpos($row_id, "_${value}_");
        if ($pos === FALSE) {
          continue;
        }
        $entity_lut = EFQE_entity_lut($value);
        if (empty($entity_lut)) {
          continue;
        }

        // Extract field name from key.
        $field_name = substr($row_id, 11, $pos - 11);
        // Skip if this was already added.
        if (array_key_exists($entity_type, $fields_by_type) && array_key_exists($field_name, $fields_by_type[$entity_type])) {
          continue;
        }
        $fields_by_type[$entity_type][$field_name] = $field_name;

        // Add in additional fields.
        $len = strlen("_${value}_entity");
        foreach ($this->view->query->fields as $name => $data) {
          $pos = strrpos($name, "_${value}_entity");
          if ($pos !== FALSE && strlen($name) == $len + $pos) {
            $views_field_name = substr($name, 11, $pos - 11);
            $fields_by_type[$entity_type][$views_field_name] = $views_field_name;
          }
        }
      }
    }

    // Load the entities.
    foreach ($entities_by_type as $entity_type => $entity_ids) {
      $entity_info = entity_get_info($entity_type);
      if (empty($this->definition['is revision'])) {
        $entities = array();
        $entity_lut = EFQE_entity_lut($entity_type);

        if (!empty($entity_lut['id']) && !empty($fields_by_type[$entity_lut['type']])) {
          $cardinality_count = array('1' => 0, '-1' => 0, '1+' => 0);
          foreach ($fields_by_type[$entity_lut['type']] as $field) {
            // Dealing with high cardinality is difficult.
            $field_info = field_info_field($field);
            if ($field_info['cardinality'] == 1) {
              $cardinality_count['1']++;
              continue;
            }
            elseif ($field_info['cardinality'] == -1) {
              $cardinality_count['-1']++;
              continue;
            }
            else {
              $cardinality_count['1+']++;
            }
          }

          if ($cardinality_count['1+'] == 0 && $cardinality_count['-1'] <= 1) {
            $query = new EntityFieldQueryExtra();
            $query
              ->entityCondition('entity_type', $entity_lut['type'])
              ->propertyCondition($entity_lut['id'], $entity_ids)
              ->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
            foreach ($fields_by_type[$entity_lut['type']] as $field) {
              // Only add in the field if it is appart of this entity type.
              $field_info = field_info_field($field);
              if (!empty($field_info['bundles'][$entity_lut['type']])) {
                $query->getFieldValue($field, '#ALL');
              }
            }
            // Add in all base properties for this entity type.
            foreach ($entity_lut['schema_fields_sql']['base table'] as $column) {
              if (!array_key_exists($column, $query->addedProperties)) {
                $query->getPropertyValue($column);
              }
            }
            $results = $query->executeEntityBuild();
            $entities = $results[$entity_lut['name']];
          }
        }
        // Fallback to entity_load if EFQE failed.
        if (empty($entities)) {
          $entities = entity_load($entity_type, $entity_ids);
        }
        $keys = $entity_ids;
      }
      else {
        // Revisions can't be loaded multiple, so we have to load them
        // one by one.
        $entities = array();
        $keys = array();
        foreach ($entity_ids as $key => $combined) {
          list($entity_id, $revision_id) = $combined;
          $entity = entity_load($entity_type, array($entity_id), array($entity_info['entity keys']['revision'] => $revision_id));
          if ($entity) {
            $entities[$revision_id] = array_shift($entity);
            $keys[$key] = $revision_id;
          }
        }
      }

      foreach ($keys as $key => $entity_id) {
        // If this is a revision, load the revision instead.
        if (isset($entities[$entity_id])) {
          $values[$key]->_field_data[$this->field_alias] = array(
            'entity_type' => $entity_type,
            'entity' => $entities[$entity_id],
          );
        }
      }
    }

    // Now, transfer the data back into the result set so it can be easily used.
    foreach ($values as $row_id => &$value) {
      $value->{'field_' . $this->options['id']} = $this->set_items($value, $row_id);
    }
  }
}

function EFQE_entity_lut($e_type = '', $b_table = '', $e_id = '') {
  // Use the advanced drupal_static() pattern.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['entity_info'] = &drupal_static(__FUNCTION__);
  }
  $lut = &$drupal_static_fast['entity_info'];

  // Set $entity_info if it is empty.
  if (empty($lut)) {
    $lut = array();
    $tables = array(
      'base table' => 'base table schema',
      'revision table' => 'revision table schema',
    );

    // 0 = Copy Key & Value.
    // 1 = Copy Key & Value to top level.
    // 2 = run array_keys on it.
    // 3 = get first value in array.
    $keys_to_copy = array(
      'plural label' => 0,
      'base table' => 0,
      'revision table' => 0,
      'entity keys' => 1,
      'bundle keys' => 3,
      'bundles' => 2,
      'schema_fields_sql' => 0,
      'base table schema' => 0,
      'revision table schema' => 0,
    );
    $entity_info = entity_get_info();
    foreach ($entity_info as $entity_type => &$info) {
      foreach ($tables as $k => $v) {
        if (empty($info[$k])) {
          continue;
        }
        $info[$v] = drupal_get_schema($info[$k]);
        unset($info[$v]['fields']);
        if (isset($info[$v]['foreign keys'])) {
          foreach ($info[$v]['foreign keys'] as $data) {
            $schema = drupal_get_schema($data['table']);
            $fields = array_keys($schema['fields']);
            unset($schema['fields']);
            $schema['fields'] = $fields;
            $info[$v]['foreign key tables'][$data['table']] = $schema;
          }
        }
      }


      $lut[$entity_type] = array();
      $lut[$entity_type]['name'] = $entity_type . 's';
      $lut[$entity_type]['type'] = $entity_type;
      foreach ($keys_to_copy as $key => $mode) {
        if (empty($info[$key])) {
          continue;
        }
        if ($mode == 0) {
          $lut[$entity_type][$key] = $info[$key];
        }
        if ($mode == 1) {
          $lut[$entity_type] += $info[$key];
        }
        if ($mode == 2) {
          $lut[$entity_type][$key] = array_keys($info[$key]);
        }
        if ($mode == 3) {
          $lut[$entity_type][$key] = reset($info[$key]);
        }
      }

      if (!empty($lut[$entity_type]['bundle'])) {
        $base = $lut[$entity_type]['bundle'];
        $alias = $base;
        if (!empty($lut[$entity_type]['bundle keys'])) {
          $base = $lut[$entity_type]['bundle keys'];
        }
        foreach ($lut[$entity_type]['schema_fields_sql'] as $type => $fields) {
          if (in_array($base, $fields)) {
            $lut[$entity_type]['bundle table info'] = array($lut[$entity_type][$type], $base, $alias);
          }
        }
        // Search for bundle in foreign keys.
        if (empty($lut[$entity_type]['bundle table info'])) {
          foreach ($tables as $k => $v) {
            if (empty($lut[$entity_type][$v]['foreign key tables'])) {
              continue;
            }
            foreach ($lut[$entity_type][$v]['foreign key tables'] as $table_name => $data) {
              if (in_array($base, $data['fields'])) {
                $lut[$entity_type]['bundle table info'] = array($table_name, $base, $alias);
              }
            }
          }
        }
      }
    }

    // Add in additional info.
    $lut['comment']['entity field pre processing'] = array(
      // From CommentController::buildQuery().
      array(
        'method' => 'getPropertyValue',
        'args' => array('name', 'users', 'registered_name'),
      ),
      array(
        'method' => 'getPropertyValue',
        'args' => array('uid', 'users', 'u_uid'),
      ),
      array(
        'method' => 'getPropertyValue',
        'args' => array('signature', 'users', 'signature'),
      ),
      array(
        'method' => 'getPropertyValue',
        'args' => array('signature_format', 'users', 'signature_format'),
      ),
      array(
        'method' => 'getPropertyValue',
        'args' => array('picture', 'users', 'picture'),
      ),
    );
    $lut['comment']['entity field post processing'] = array(
      // From CommentController::attachLoad().
      array(
        'args' => array('uid', 'registered_name', 'name'),
        'new_key' => 'name',
        'function' => 'efqe_comment_name',
      ),
      array(
        'args' => array('nid', 'changed'),
        'new_key' => 'new',
        'function' => 'efqe_comment_new',
      ),
      array(
        'args' => array('node_type'),
        'new_key' => 'node_type',
        'function' => 'efqe_comment_node_type',
      ),
    );
    $lut['user']['entity field pre processing'] = array(
      // From UserController::attachLoad().
      array(
        'method' => 'getPropertyValue',
        'args' => array('roles'),
      ),
    );
  }

  // Return the values.
  if (!empty($e_type)) {
    if (!empty($lut[$e_type])) {
      return $lut[$e_type];
    }
    else {
      return array();
    }
  }
  if (!empty($b_table)) {
    foreach ($lut as $values) {
      if ($values['base table'] == $b_table) {
        return $values;
      }
    }
    return array();
  }
  if (!empty($e_id)) {
    foreach ($lut as $values) {
      if ($values['id'] == $e_id) {
        return $values;
      }
    }
    return array();
  }
  return $lut;
}

function efqe_comment_name($uid, $registered_name, $name) {
  return $uid ? $registered_name : $name;
}

function efqe_comment_new($nid, $changed) {
  return node_mark($nid, $changed);
}

function efqe_comment_node_type($type) {
  return 'comment_node_' . $type;
}

/**
 * Alternative version of field_sql_storage_field_storage_query().
 */
function EntityFieldQueryExtra_field_sql_storage_field_storage_query(EntityFieldQuery $query) {
  if ($query->age == FIELD_LOAD_CURRENT) {
    $tablename_function = '_field_sql_storage_tablename';
    $id_key = 'entity_id';
  }
  else {
    $tablename_function = '_field_sql_storage_revision_tablename';
    $id_key = 'revision_id';
  }
  $table_aliases = array();
  // Use base table if no conditions and only left joins.
  $first = TRUE;
  if (!empty($query->changeBaseTable)) {
    $select_query = db_select($query->changeBaseTable, $query->changeBaseTable);
    $field_base_table = $query->changeBaseTable;
    $first = FALSE;

    $entity_lut = EFQE_entity_lut('', $field_base_table);
    $base_id = $entity_lut['id'];

    $select_query->addField($field_base_table, $base_id);
  }
  // Add tables for the fields used.
  $second_table_alias = FALSE;
  foreach ($query->fields as $key => $field) {
    $tablename = $tablename_function($field);
    // Every field needs a new table.
    $table_alias = $tablename . $key;
    $table_aliases[$key] = $table_alias;
    if (!$first) {
      if (!empty($query->changeBaseTable)) {
        $select_query->join($tablename, $table_alias, "$table_alias.$id_key = $field_base_table.$base_id");
      }
      else {
        $select_query->join($tablename, $table_alias, "$table_alias.entity_type = $field_base_table.entity_type AND $table_alias.$id_key = $field_base_table.$id_key");
      }
      if (empty($second_table_alias)) {
        $second_table_alias = $field_base_table;
      }
    }
    else {
      $select_query = db_select($tablename, $table_alias);
      // Allow queries internal to the Field API to opt out of the access
      // check, for situations where the query's results should not depend on
      // the access grants for the current user.
      if (!isset($query->tags['DANGEROUS_ACCESS_CHECK_OPT_OUT'])) {
        $select_query->addTag('entity_field_access');
      }
      $select_query->addMetaData('base_table', $tablename);
      if ($query->executeQuery) {
        $select_query->fields($table_alias, array('entity_type', 'entity_id', 'revision_id', 'bundle'));
      }
      else {
        $select_query->fields($table_alias, array('entity_id'));
      }
      $field_base_table = $table_alias;
      $first = FALSE;
    }
    if ($field['cardinality'] != 1 || $field['translatable']) {
      $select_query->distinct();
    }
  }
  if (empty($second_table_alias)) {
    $second_table_alias = $table_alias;
  }

  // Add field conditions. We need a fresh grouping cache.
  drupal_static_reset('_field_sql_storage_query_field_conditions');
  _field_sql_storage_query_field_conditions($query, $select_query, $query->fieldConditions, $table_aliases, '_field_sql_storage_columnname');

  // Add field meta conditions.
  _field_sql_storage_query_field_conditions($query, $select_query, $query->fieldMetaConditions, $table_aliases, '_field_sql_storage_query_columnname');

  if (isset($query->deleted) && empty($query->changeBaseTable)) {
    $select_query->condition("$second_table_alias.deleted", (int) $query->deleted);
  }

  // Is there a need to sort the query by property?
  $has_property_order = FALSE;
  foreach ($query->order as $order) {
    if ($order['type'] == 'property') {
      $has_property_order = TRUE;
    }
  }

  if ($query->propertyConditions || $has_property_order) {
    if (empty($query->entityConditions['entity_type']['value'])) {
      throw new EntityFieldQueryException('Property conditions and orders must have an entity type defined.');
    }
    $entity_type = $query->entityConditions['entity_type']['value'];
    if (empty($query->changeBaseTable)) {
      $entity_base_table = _field_sql_storage_query_join_entity($select_query, $entity_type, $field_base_table);
    }
    else {
      $entity_base_table = $query->changeBaseTable;
    }
    $query->entityConditions['entity_type']['operator'] = '=';
    foreach ($query->propertyConditions as $key => $property_condition) {
      // Handle user roles.
      if ($property_condition['column'] == 'rolename') {
        // Direct join is faster than a select join.
        $select_query->join('users_roles', 'users_roles' . $key, "users_roles$key.uid = $entity_base_table.uid");
        $select_query->join('role', 'role' . $key, "role$key.rid = users_roles$key.rid AND role$key.name " . EntityFieldQueryExtra_get_op($property_condition) . EntityFieldQueryExtra_get_args($property_condition, $key), EntityFieldQueryExtra_get_args_values($property_condition, $key));
      }
      elseif ($property_condition['column'] == 'rid') {
        // Direct join is faster than a select join.
        $select_query->join('users_roles', 'users_roles' . $key, "users_roles$key.uid = $entity_base_table.uid AND users_roles$key.rid " . EntityFieldQueryExtra_get_op($property_condition) . EntityFieldQueryExtra_get_args($property_condition, $key), EntityFieldQueryExtra_get_args_values($property_condition, $key));
      }
      else {
        $query->addCondition($select_query, "$entity_base_table." . $property_condition['column'], $property_condition);
      }
    }
  }
  if (!empty($query->changeBaseTable)) {
    $query->entity_type = $query->entityConditions['entity_type']['value'];
    unset($query->entityConditions['entity_type']);
    if (isset($query->entityConditions['bundle'])) {
      $query->entityConditions['type'] = $query->entityConditions['bundle'];
      $query->bundle = $query->entityConditions['bundle']['value'];
      unset($query->entityConditions['bundle']);
    }
  }
  foreach ($query->entityConditions as $key => $condition) {
    $query->addCondition($select_query, "$field_base_table.$key", $condition);
  }

  // Order the query.
  foreach ($query->order as $order) {
    if ($order['type'] == 'entity') {
      $key = $order['specifier'];
      $select_query->orderBy("$field_base_table.$key", $order['direction']);
    }
    elseif ($order['type'] == 'field') {
      $specifier = $order['specifier'];
      $field = $specifier['field'];
      $table_alias = $table_aliases[$specifier['index']];
      $sql_field = "$table_alias." . _field_sql_storage_columnname($field['field_name'], $specifier['column']);
      $select_query->orderBy($sql_field, $order['direction']);
    }
    elseif ($order['type'] == 'property') {
      $select_query->orderBy("$entity_base_table." . $order['specifier'], $order['direction']);
    }
  }
  if (!empty($query->changeBaseTable)) {
    $id_key = $base_id;
  }

  return $query->finishQuery($select_query, $id_key);
}

// PDO join condition helper.
function EntityFieldQueryExtra_get_op($property_condition) {
  $operator = $property_condition['operator'];
  $value = $property_condition['value'];
  if (!isset($operator)) {
    if (is_array($value)) {
      $operator = 'IN';
    }
    elseif (!isset($value)) {
      $operator = 'IS NULL';
    }
    else {
      $operator = '=';
    }
  }
  return $operator;
}

// PDO join condition helper.
function EntityFieldQueryExtra_get_args($property_condition, $key) {
  $operator = $property_condition['operator'];
  $value = $property_condition['value'];
  $col = $property_condition['column'];

  $return = '';
  if (is_array($value)) {
    foreach ($value as $k => $v) {
      $return[] = ":efqe_${col}_${key}_${k}";
    }
    $return = "(" . implode(', ', $return) . ")";
  }
  else {
    $return = ":efqe_${col}_${key}";
  }
  return $return;
}

// PDO join condition helper.
function EntityFieldQueryExtra_get_args_values($property_condition, $key) {
  $operator = $property_condition['operator'];
  $value = $property_condition['value'];
  $col = $property_condition['column'];

  $return = array();
  if (is_array($value)) {
    foreach ($value as $k => $v) {
      $return[":efqe_${col}_${key}_${k}"] = $v;
    }
  }
  else {
    $return = array(":efqe_${col}_${key}" => $value);
  }
  return $return;
}

function EntityFieldQueryExtra_entity_create($values, $field_names, $entity_lut) {
  $object = new stdClass();
  foreach ($values as $k => $v) {
    if (!array_key_exists($k, $field_names)) {
      $object->{$k} = $v;
    }
  }
  // Put fields in at the bottom of the object.
  foreach ($values as $k => $v) {
    if (!array_key_exists($k, $field_names)) {
      continue;
    }
    if (is_array($v)) {
      foreach ($v as $a => $b) {
        $object->{$field_names[$k][0]}['und'][$a][$field_names[$k][1]] = $b;
      }
    }
    else {
      $object->{$field_names[$k][0]}['und'][0][$field_names[$k][1]] = $v;
    }
  }

  // Remove empty fields.
  EntityFieldQueryExtra_entity_create_kill_null($object, $values, $field_names);

  // unserialize data if it has been serialized.
  if (isset($object->{'data'})) {
    $data = @unserialize($object->{'data'});
    if ($object->{'data'} === 'b:0;' || $data !== FALSE) {
      $object->{'data'} = $data;
    }
  }

  // Preform any post processing.
  if (!empty($entity_lut['entity field post processing'])) {
    foreach ($entity_lut['entity field post processing'] as $rule) {
      if (!empty($rule['function']) && is_callable($rule['function'])) {
        $args = array();
        foreach ($rule['args'] as $arg) {
          $args[] = isset($object->{$arg}) ? $object->{$arg} : NULL;
        }
        $object->{$rule['new_key']} = call_user_func_array($rule['function'], $args);
      }
      else {
        $object->{$rule['new_key']} = $object->$rule['old_key'];
      }
    }
  }

  return $object;
}

function EntityFieldQueryExtra_entity_create_kill_null(&$object) {
  foreach ($object as $key => $values) {
    if (!isset($values['und'])) {
      continue;
    }
    $all_null = TRUE;
    foreach ($values['und'] as $delta => $data) {
      foreach ($data as $info) {
        if (!is_null($info)) {
          $all_null = FALSE;
          break 2;
        }
      }
    }
    if ($all_null) {
      unset($object->{$key}['und']);
      $object->{$key} = array();
    }
  }
}

class EntityFieldQueryExtra extends EntityFieldQuery {
  // Variables used internally.
  private $addedFields = array();
  private $showQuery = FALSE;
  private $printQuery = FALSE;
  private $EFQpropertyConditions = array();
  private $EFQjoin = array();

  // Variables used internally & externally.
  public $addedProperties = array();
  public $changeBaseTable = FALSE;
  public $executeQuery = TRUE;
  public $entity_type = NULL;
  public $bundle = NULL;
  public $get_user_roles = FALSE;
  public $fields_to_entity = array();
  public $remove_ordered_results = FALSE;

  public function removeOrderedResults() {
    $this->remove_ordered_results = TRUE;
    return $this;
  }

  public function executeEntityLoad() {
    if (isset($this->entityConditions['entity_type']['value'])) {
      $entity_type = $this->entityConditions['entity_type']['value'];
    }
    $entity_lut = EFQE_entity_lut($entity_type);

    $results = $this->execute();
    $eid = array_keys($results[$entity_lut['type']]);
    $results[$entity_lut['name']] = entity_load($entity_lut['type'], $eid);

    return $results;
  }

  public function executeEntityBuildAll() {
    // Get entity and bundle name.
    $entity_type = NULL;
    $bundle_name = NULL;
    if (isset($this->entityConditions['entity_type']['value'])) {
      $entity_type = $this->entityConditions['entity_type']['value'];
      if (isset($this->entityConditions['bundle']['value'])) {
        $bundle_name = $this->entityConditions['bundle']['value'];
      }
    }

    // Get all Properties.
    $entity_info = entity_get_info($entity_type);
    $properties = $entity_info['schema_fields_sql']['base table'];
    foreach ($properties as $column) {
      if (!array_key_exists($column, $this->addedProperties)) {
        $this->getPropertyValue($column);
      }
    }

    // Get user roles if base table has a uid.
    if (in_array('uid', $properties)) {
      $this->getPropertyValue('roles');
    }

    // Get all fields.
    $fields_info = field_info_instances($entity_type, $bundle_name);
    $field_output = array();
    if (is_null($bundle_name)) {
      if (isset($fields_info[$entity_type])) {
        foreach ($fields_info[$entity_type] as $field_name => $value) {
          $field_info = field_info_field($field_name);
          $output = reset($field_info['storage']['details']['sql']['FIELD_LOAD_CURRENT']);
          $field_output[$field_name] = array_keys($output);
        }
      }
      else {
        // Need to group joins into a select join by $bundle_name in order to avoid the 61 table limit.
        foreach ($fields_info as $bundle_name => $bundle_fields) {
          foreach ($bundle_fields as $field_name => $value) {
            $field_info = field_info_field($field_name);
            $output = reset($field_info['storage']['details']['sql']['FIELD_LOAD_CURRENT']);
            $field_output[$field_name] = array_keys($output);
          }
        }
      }
    }
    else {
      foreach ($fields_info as $field_name => $value) {
        $field_info = field_info_field($field_name);
        $output = reset($field_info['storage']['details']['sql']['FIELD_LOAD_CURRENT']);
        $field_output[$field_name] = array_keys($output);
      }
    }

    foreach ($field_output as $field_name => $columns) {
      foreach ($columns as $column) {
        if (!array_key_exists($field_name . '_' . $column, $this->addedFields)) {
          $this->getFieldValue($field_name, $column, 'LEFT');
        }
      }
    }

    // Run the query.
    return $this->executeEntityBuild();
  }

  public function executeEntityBuild() {
    if (isset($this->entityConditions['entity_type']['value'])) {
      $entity_type = $this->entityConditions['entity_type']['value'];
    }
    $entity_lut = EFQE_entity_lut($entity_type);

    // Add in bundle table fields.
    if (!empty($entity_lut['bundle table info'])) {
      $this->getPropertyValue($entity_lut['bundle table info'][1], $entity_lut['bundle table info'][0], $entity_lut['bundle table info'][2]);
    }

    // Add in any additional fields.
    if (!empty($entity_lut['entity field pre processing'])) {
      foreach ($entity_lut['entity field pre processing'] as $pre_process) {
        if (isset($pre_process['method']) && is_callable(array($this, $pre_process['method']))) {
          call_user_func_array(array($this, $pre_process['method']), $pre_process['args']);
        }
      }
    }

    $results = $this->execute();
    $results[$entity_lut['name']] = array();
    if (!empty($results[$entity_lut['type']])) {
      foreach($results[$entity_lut['type']] as $id => $values) {
        $results[$entity_lut['name']][$id] = EntityFieldQueryExtra_entity_create($values, $this->fields_to_entity, $entity_lut);
      }
    }
    return $results;
  }

  public function execute() {
    // Sort field arrays so tables added via getFieldValue are joined last.
    if (!empty($this->fields)) {
      // Sort fields so conditional fields show up first.
      ksort($this->fields);
      // If we have no conditions on the fields use our alt callback.
      if (!array_key_exists(0, $this->fields)) {
        $entity_info = entity_get_info($this->entityConditions['entity_type']['value']);
        $base_table = $entity_info['base table'];
        $this->changeBaseTable = $base_table;
        foreach ($this->fields as $index => $field) {
          if (!isset($storage)) {
            $storage = $field['storage']['module'];
          }
          elseif ($storage != $field['storage']['module']) {
            throw new EntityFieldQueryException(t("Can't handle more than one field storage engine"));
          }

          foreach ($this->addedFields as $values) {
            if ($values['index'] == $index && $values['join_type'] == 'INNER') {
              unset($this->fields[$index]);
              // array_unshift while preserving keys.
              $this->fields = array($index => $field) + $this->fields;
              $this->changeBaseTable = FALSE;
            }
          }
        }
        if ($storage != 'field_sql_storage') {
          throw new EntityFieldQueryException(t("Can only handle the field_sql_storage engine"));
        }

        $this->executeCallback = 'EntityFieldQueryExtra_field_sql_storage_field_storage_query';
      }
    }

    if (empty($this->executeCallback)) {
      foreach ($this->propertyConditions as $property_condition) {
        // Handle user role conditions.
        if ($property_condition['column'] == 'rolename' || $property_condition['column'] == 'rid') {
          $this->executeCallback = 'EntityFieldQueryExtra_field_sql_storage_field_storage_query';
          break;
        }
      }
    }

    return parent::execute();
  }

  public function EFQjoin($type, $table, $on, $conditions = array(), $fields = array(), $alt_base_table = '') {
    $this->EFQjoin[] = array($type, $table, $on, $conditions, $fields, $alt_base_table);
    return $this;
  }

  public function EFQpropertyCondition(EntityFieldQueryExtra $efqe_sub, $column) {
    $efqe_sub->executeQuery = FALSE;
    $efqe_sub->executeCallback = 'EntityFieldQueryExtra_field_sql_storage_field_storage_query';
    $this->EFQpropertyConditions[] = array($efqe_sub->execute(), $column);
    $efqe_sub->executeQuery = TRUE;
    $efqe_sub->executeCallback = NULL;

    return $this;
  }

  public function propertyOrderBy($column, $direction = 'ASC', $table = '') {
    $order_array = array(
      'specifier' => $column,
      'direction' => $direction,
    );

    if (empty($table)) {
      $order_array += array(
        'type' => 'property',
      );
    }
    else {
      $order_array += array(
        'type' => 'alt_base_table_property',
        'table' => $table,
      );
    }
    $this->order[] = $order_array;
    return $this;
  }

  /**
   * Add extra field data to the output.
   *
   * @param string $field
   *   Either a field name or a field array.
   * @param string $column
   *   A column defined in the hook_field_schema() of this field. entity_id
   *   and bundle can also be used.
   * @param string $join_type
   *   (optional) What type of join to use. Default is LEFT.
   *
   * @return EntityFieldQuery
   *   The called object.
   */
  public function getFieldValue($field, $column, $join_type = 'LEFT', $base_table = array()) {
    // Add field to the main query.
    if (is_scalar($field)) {
      $field_definition = field_info_field($field);
      if (empty($field_definition)) {
        throw new EntityFieldQueryException(t('Unknown field: @field_name', array('@field_name' => $field)));
      }
      $field = $field_definition;
    }

    // Save the index used for the new field, for later use in field storage.
    $index = $this->saveFieldIndex($field);

    $columns = array();
    if ($column == '#ALL') {
      foreach ($field['columns'] as $column => $values) {
        $columns[] = $column;
      }
    }
    else {
      $columns[] = $column;
    }
    foreach ($columns as $column) {
      // Save data needed in the finishQuery() method.
      $added_fields = array(
        'field_name' => $field['field_name'],
        'column' => $column,
        'index' => $index,
        'join_type' => $join_type,
        'base_table' => $base_table,
        'field' => $field,
      );
      $this->addedFields[$field['field_name'] . '_' . $column] = $added_fields;
      $this->fields_to_entity[$field['field_name'] . '_' . $column] = array($field['field_name'], $column);
    }
    return $this;
  }

  /**
   * Add extra property data to the output.
   *
   * @param string $column
   *   A column defined in the hook_field_schema() of the entity.
   *
   * @return EntityFieldQuery
   *   The called object.
   */
  public function getPropertyValue($column, $base_table = '', $alias = '') {
    // Save data needed in the finishQuery() method.
    $this->addedProperties[$column.$base_table.$alias] = array(
      $column,
      $base_table,
      $alias,
    );
    return $this;
  }

  /**
   * Add the query that was ran to the returned object under the #query key.
   *
   * @param bool $bool
   *   Set to TRUE to see the query being ran.
   *
   * @return EntityFieldQuery
   *   The called object.
   */
  public function showQuery($bool = TRUE) {
    // Save data needed in the finishQuery() method.
    $this->showQuery = $bool;
    return $this;
  }

  /**
   * Print out the query that is going to ran.
   *
   * @param bool $bool
   *   Set to TRUE to print out the query being ran.
   *
   * @return EntityFieldQuery
   *   The called object.
   */
  public function printQuery($bool = TRUE) {
    // Save data needed in the finishQuery() method.
    $this->printQuery = $bool;
    return $this;
  }

  /**
   * Finishes the query.
   *
   * Adds tags, meta data, range and returns the requested list or count.
   *
   * @param SelectQuery $select_query
   *   A SelectQuery which has entity_type, entity_id, revision_id and bundle
   *   fields added.
   * @param string $id_key
   *   Which field's values to use as the returned array keys.
   *
   * @return
   *   See EntityFieldQuery::execute().
   */
  function finishQuery($select_query, $id_key = 'entity_id') {
    $columns = $this->_prep_final_query($select_query, $id_key);
    if ($this->executeQuery) {
      return $this->_execute_final_query($select_query, $id_key, $columns);
    }
    else {
      return $select_query;
    }
  }

  /**
   * Check if the field already has a table that does a join.
   *
   * @param array $field
   *   field array from field_info_field().
   *
   * @return int
   *   key position in $this->fields array.
   */
  private function saveFieldIndex($field) {
    $fields = $this->fields;
    foreach ($fields as $index => $field_info) {
      if (isset($field_info['field_name']) && $field_info['field_name'] == $field['field_name']) {
        return $index;
      }
    }
    // Add these tables in after conditions.
    $index = 100;
    if (isset($field['storage'])) {
      $index += count($this->fields);
      $this->fields[$index] = $field;
    }
    return $index;
  }

  function _join_foreign_keys(&$select_query, $id_key) {
    foreach ($this->addedFields as $fields) {
      if (empty($fields['field']['foreign keys'])) {
        continue;
      }
      foreach ($fields['field']['foreign keys'] as $key => $info) {
        if ($key != $fields['column']) {
          continue;
        }
        $entity_lut = EFQE_entity_lut('', '', $key);
        if (empty($entity_lut)) {
          continue;
        }
        // Get all Properties.
        $properties = $entity_lut['schema_fields_sql']['base table'];
        $columns = array();
        foreach ($properties as $column) {
          $columns[$column] = $fields['field_name'] . '_' . $column;
          $this->fields_to_entity[$fields['field_name'] . '_' . $column] = array(
            $fields['field_name'],
            $column,
          );
        }
        $sql_table = key($fields['field']['storage']['details']['sql']['FIELD_LOAD_CURRENT']);
        $on = $fields['field']['storage']['details']['sql']['FIELD_LOAD_CURRENT'][$sql_table][$key];

        // Add in the join.
        $this->EFQjoin('LEFT', $entity_lut['base table'], array($entity_lut['id'], $on), array(), $columns, $sql_table);
      }
    }
  }

  private function _prep_efq_join(&$select_query, $id_key = 'entity_id') {
    // Get base table for join.
    $tables =& $select_query->getTables();
    $base_table = '';
    foreach ($tables as &$t) {
      if (is_null($t['join type']) && is_null($t['condition'])) {
        $base_table = $t['alias'];
        break;
      }
    }

    foreach ($this->EFQjoin as $k => $values) {
      // Set initial values.
      list($type, $table, $on, $conditions, $fields, $alt_base_table) = $values;
      $table_alias = $table . $k;

      // Get row from base table to join on.
      if (is_array($on)) {
        $row = $on[1];
        $on = $on[0];
      }
      else {
        $row = $on;
      }
      if (empty($alt_base_table)) {
        $alt_base_table = $base_table;
        if (empty($this->changeBaseTable)) {
          $row = $id_key;
        }
      }
      else {
        foreach ($tables as &$t) {
          if ($t['table'] == $alt_base_table) {
            $alt_base_table = $t['alias'];
            break;
          }
        }
      }

      // Build conditions and arguments.
      $condition = "$table_alias.$on = $alt_base_table.$row";
      $arguments = array();
      if (!empty($conditions)) {
        foreach ($conditions as $i => $join_condition) {
          $property_condition['column'] = $join_condition[0];
          $property_condition['value'] = $join_condition[1];
          $property_condition['operator'] = isset($join_condition[2]) ? $join_condition[2] : NULL;
          $key = "${k}_${i}";
          $condition .= " AND $table_alias.$join_condition[0] " . EntityFieldQueryExtra_get_op($property_condition) . ' ' . EntityFieldQueryExtra_get_args($property_condition, $key);
          $arguments += EntityFieldQueryExtra_get_args_values($property_condition, $key);
        }
      }
      $select_query->addJoin($type, $table, $table_alias, $condition, $arguments);

      // Add in fields.
      if (!empty($fields)) {
        foreach ($fields as $field => $field_alias) {
          $select_query->addField($table_alias, $field, $field_alias);
        }
      }
    }
  }

  private function _prep_final_query($select_query, $id_key = 'entity_id') {
    // Do nested condition.
    if (!empty($this->EFQpropertyConditions)) {
      foreach ($this->EFQpropertyConditions as $values) {
        $select_query->condition("node.$values[1]", $values[0], 'IN');
      }
    }

    // Join foreign keys.
    $this->_join_foreign_keys($select_query, $id_key);

    // Do EFQ join.
    if (!empty($this->EFQjoin)) {
      $this->_prep_efq_join($select_query, $id_key);
    }

    // Iterate through all fields. If the query is trying to fetch results
    // where a field is null, then alter the query to use a LEFT OUTER join.
    // Otherwise the query will always return 0 results.
    foreach ($this->fieldConditions as $key => $fieldCondition) {
      if ($fieldCondition['operator'] == 'IS NULL' && isset($this->fields[$key]['storage']['details']['sql'][FIELD_LOAD_CURRENT])) {
        $tables =& $select_query->getTables();
        foreach ($tables as &$table) {
          $keys = array_keys($this->fields[$key]['storage']['details']['sql'][FIELD_LOAD_CURRENT]);
          $sql_table = reset($keys);
          if ($table['table'] == $sql_table) {
            $table['join type'] = 'LEFT OUTER';
          }
        }
      }
    }

    // Same as EntityFieldQuery::execute()
    foreach ($this->tags as $tag) {
      $select_query->addTag($tag);
    }
    foreach ($this->metaData as $key => $object) {
      $select_query->addMetaData($key, $object);
    }
    $select_query->addMetaData('entity_field_query', $this);
    if ($this->range) {
      $select_query->range($this->range['start'], $this->range['length']);
    }
    if ($this->count) {
      return $select_query->countQuery()->execute()->fetchField();
    }

    // Change join condition if base table is changing.
    $columns = array();
    foreach($this->addedFields as $addedField) {
      if (empty($addedField['base_table'])) {
        continue;
      }
      $sql_table = key($addedField['field']['storage']['details']['sql']['FIELD_LOAD_CURRENT']);
      $tables =& $select_query->getTables();
      $base_table_col = reset($addedField['base_table']);
      $base_table_alias = key($addedField['base_table']);
      $counter_a = 0;
      $table_found = FALSE;
      foreach ($tables as &$table) {
        $counter_a++;
        if ($table['table'] == $base_table_alias) {
          if (isset($addedField['field']['bundles'][$base_table_alias])) {
            $bundle_type = reset($addedField['field']['bundles'][$base_table_alias]);
            if (in_array($bundle_type, $table['arguments'])) {
              $base_table_alias = $table['alias'];
              $table_found = TRUE;
              break;
            }
          }
        }
      }
      if (!$table_found) {
        $counter_a = 0;
        $table_found = FALSE;
        foreach ($tables as &$table) {
          $counter_a++;
          if ($table['table'] == $base_table_alias) {
            $base_table_alias = $table['alias'];
            $table_found = TRUE;
            break;
          }
        }
      }
      $counter_b = 0;
      $moved_tables = array();
      foreach ($tables as $k => &$table) {
        $counter_b++;
        if ($table['table'] != $sql_table) {
          continue;
        }
        $table_alias = $table['alias'];
        $table['condition'] = "$base_table_alias.$base_table_col = $table_alias.$id_key";
        if ($counter_a > $counter_b) {
          $moved_tables[$k] = $table;
          unset($tables[$k]);
        }
      }
      $tables += $moved_tables;
    }

    // Fix table order so joins work.
    $tables =& $select_query->getTables();
    $aliases = array();
    foreach ($tables as &$table) {
      $aliases[] = $table['alias'];
    }
    $conditions = array();
    foreach ($tables as &$table) {
      $conditions[$table['alias']] = array();
      if (!empty($table['condition'])) {
        foreach ($aliases as $a) {
          if (strpos($table['condition'], $a) !== FALSE) {
            $conditions[$table['alias']][] = $a;
          }
        }
      }
    }
    $counter = 0;
    foreach ($conditions as $k => $v) {
      $counter++;
      $test_array = array_slice($aliases, 0, $counter);
      $diff = array_diff($v, $test_array);
      if (!empty($diff)) {
        $table_name = reset($diff);
        $temp_table = $tables[$k];
        unset($tables[$k]);
        $tables[$k] = $temp_table;
      }
    }

    // Get field value.
    $columns = array();
    foreach ($this->addedFields as $addedField) {
      // Add field to query.
      $column = $addedField['field_name'] . '_' . $addedField['column'];
      $table_name = 'field_data_' . $addedField['field_name'] . $addedField['index'];
      $select_query->addField($table_name, $column);

      // Change join type if requested to do so.
      if (!empty($addedField['join_type'])) {
        $tables =& $select_query->getTables();
        foreach ($tables as &$table) {
          if ($table['alias'] == $table_name && !is_null($table['join type'])) {
            $table['join type'] = $addedField['join_type'];
          }
        }
      }

      $columns[] = $column;
    }

    // Add in needed properties.
    // Get the entity base table.
    if (isset($this->entityConditions['entity_type']['value'])) {
      $entity_info = entity_get_info($this->entityConditions['entity_type']['value']);
      $base_table = $entity_info['base table'];
    }
    else {
      $base_table = $this->changeBaseTable;
    }

    // Get property value.
    if (!empty($this->addedProperties)) {
      foreach($this->addedProperties as $key => $column) {
        if ($column[0] == 'roles') {
          // Special case for user roles.
          $role_alias = 'role_' . $key;
          $users_role_alias = 'users_roles_' . $key;
          $users_role_alias_found = FALSE;
          $role_alias_found = FALSE;
          $base_table_found = FALSE;

          // Reuse tables if possible.
          $tables =& $select_query->getTables();
          foreach ($tables as &$table) {
            if ($table['table'] == 'users_roles') {
              $users_role_alias = $table['alias'];
              $users_role_alias_found = TRUE;
            }
            if ($table['table'] == 'role') {
              $role_alias = $table['alias'];
              $role_alias_found = TRUE;
            }
            if ($table['table'] == $base_table) {
              $base_table_found = TRUE;
            }
          }
          if (empty($users_role_alias_found)) {
            // Handle if the users table is not joined.
            $base_table_key = 'uid';
            if (!$base_table_found) {
              $first = reset($tables);
              $base_table = $first['alias'];
              $base_table_key = 'entity_id';
            }
            $select_query->join('users_roles', $users_role_alias, "$users_role_alias.uid = $base_table.$base_table_key");
          }
          if (empty($role_alias_found)) {
            $select_query->join('role', $role_alias, "$role_alias.rid = $users_role_alias.rid");
          }

          // Get role field info.
          $select_query->addField($role_alias, 'name', 'role_names');
          $select_query->addField($role_alias, 'rid', 'role_rids');
        }
        else {
          // Add property to query.
          if (empty($column[1])) {
            if (empty($column[2])) {
              $select_query->addField($base_table, $column[0]);
              $columns[] = $column[0];
            }
            else {
              $select_query->addField($base_table, $column[0], $column[2]);
              $columns[] = $column[2];
            }
          }
          else {
            // Reuse tables if possible.
            $tables =& $select_query->getTables();
            $temp_base_table = $column[1];
            foreach ($tables as &$table) {
              if ($table['table'] == $column[1]) {
                $temp_base_table = $table['alias'];
                $temp_base_table_found = TRUE;
              }
            }
            if (empty($temp_base_table_found)) {
              $entity_lut = EFQE_entity_lut('', $temp_base_table);
              $base_id = $entity_lut['id'];
              $select_query->join($temp_base_table, $temp_base_table, "$temp_base_table.$base_id = $base_table.$base_id");
            }
            if (empty($column[2])) {
              $select_query->addField($temp_base_table, $column[0], $column[1] . '_' . $column[0]);
              $columns[] = $column[1] . '_' . $column[0];
            }
            else {
              $select_query->addField($temp_base_table, $column[0], $column[2]);
              $columns[] = $column[2];
            }
          }
        }
      }
    }

    // Adjust order.
    if (!empty($this->order)) {
      foreach ($this->order as $order) {
        if ($order['type'] == 'alt_base_table_property') {
          $select_query->orderBy($order['table'] . '.' . $order['specifier'], $order['direction']);
        }
      }
    }

    // Add in query debugging if needed.
    if ($this->printQuery) {
      print($this->_get_query_string($select_query));
    }
    return $columns;
  }

  private function _execute_final_query($select_query, $id_key = 'entity_id', $columns = array()) {
    $return = array();
    if ($this->showQuery) {
      $return['#query'] = $this->_get_query_string($select_query);
    }

    if (isset($this->entityConditions['entity_type']['value'])) {
      $entity_type = $this->entityConditions['entity_type']['value'];
      $base_entity_lut = EFQE_entity_lut($entity_type);
      $base_columns = $base_entity_lut['schema_fields_sql']['base table'];
      $base_columns[] = 'entity_type';
      $base_columns[] = 'entity_id';
      $base_columns[] = 'revision_id';
      $base_columns[] = 'bundle';
      $base_columns[] = 'roles';
    }

    // Run the query and iterate over each result returned.
    foreach ($select_query->execute() as $partial_entity) {
      $this->ordered_results[$partial_entity->$id_key][] = $partial_entity;
    }

    // Remove duplicates.
    if (!empty($base_columns) && !empty($this->ordered_results)) {
      foreach ($this->ordered_results as $k => $data) {
        if (count($data) == 1) {
          continue;
        }
        $values = array();
        $eids = array();
        foreach ($data as $eid => $partial_entity) {
          foreach ($partial_entity as $key => $value) {
            $values[$key][$value] = $value;
          }
          if ($eid > 0) {
            $eids[] = $eid;
          }
        }
        foreach ($values as $key => $values) {
          if (count($values) == 1 && !in_array($key, $base_columns)) {
            foreach ($eids as $eid) {
              if (isset($this->ordered_results[$k][$eid]->{$key})) {
                unset($this->ordered_results[$k][$eid]->{$key});
              }
            }
          }
        }
      }
    }

    // Run the query and iterate over each result returned.
    if (!empty($this->ordered_results)) {
      foreach ($this->ordered_results as $x => $data) {
        foreach ($data as $y => $partial_entity) {
          $bundle = isset($partial_entity->bundle) ? $partial_entity->bundle : $this->bundle;
          $entity_type = isset($partial_entity->entity_type) ? $partial_entity->entity_type : $this->entity_type;
          $partial_entity->entity_id = isset($partial_entity->entity_id) ? $partial_entity->entity_id : $partial_entity->$id_key;
          $revision_id = isset($partial_entity->revision_id) ? $partial_entity->revision_id : NULL;
          $entity = entity_create_stub_entity($entity_type, array($partial_entity->entity_id, $revision_id, $bundle));
          // Add in the additional fields to the entity stub.
          foreach ($partial_entity as $key => $value) {
            $entity->{$key} = $value;
          }

          foreach ($columns as $column_name) {
            if (!isset($partial_entity->{$column_name})) {
              $entity->{$column_name} = NULL;
            }
          }
          if (!isset($return[$entity_type][$partial_entity->$id_key])) {
            $return[$entity_type][$partial_entity->$id_key] = $entity;
          }
          else {
            // Handle multiple delta values.
            foreach ($entity as $k => $v) {
              // Special case roles.
              if ($k == 'roles' || is_null($v)) {
                continue;
              }
              if ((!empty($base_columns) && !in_array($k, $base_columns)) || $return[$entity_type][$partial_entity->$id_key]->$k != $v) {
                if (!is_array($return[$entity_type][$partial_entity->$id_key]->$k)) {
                  $temp = $return[$entity_type][$partial_entity->$id_key]->$k;
                  unset($return[$entity_type][$partial_entity->$id_key]->$k);
                  $return[$entity_type][$partial_entity->$id_key]->{$k} = array($temp);
                }
                $return[$entity_type][$partial_entity->$id_key]->{$k}[] = $v;
              }
            }
          }
          // Handle roles.
          if (isset($this->addedProperties['roles'])) {
            // Add in core default roles.
            if (isset($return[$entity_type][$partial_entity->$id_key]->{'uid'})) {
              if ($return[$entity_type][$partial_entity->$id_key]->{'uid'}) {
                $return[$entity_type][$partial_entity->$id_key]->{'roles'}[DRUPAL_AUTHENTICATED_RID] = 'authenticated user';
              }
              else {
                $return[$entity_type][$partial_entity->$id_key]->{'role_names'}[DRUPAL_ANONYMOUS_RID] = 'anonymous user';
              }
            }

            // Add in set roles.
            if (!empty($return[$entity_type][$partial_entity->$id_key]->{'role_names'}) && !empty($return[$entity_type][$partial_entity->$id_key]->{'role_rids'})) {
              if (!is_array($return[$entity_type][$partial_entity->$id_key]->{'role_rids'})) {
                $return[$entity_type][$partial_entity->$id_key]->{'roles'}[$return[$entity_type][$partial_entity->$id_key]->{'role_rids'}] = $return[$entity_type][$partial_entity->$id_key]->{'role_names'};
              }
              else {
                foreach ($return[$entity_type][$partial_entity->$id_key]->{'role_rids'} as $k => $v) {
                  $return[$entity_type][$partial_entity->$id_key]->{'roles'}[$v] = $return[$entity_type][$partial_entity->$id_key]->{'role_names'}[$k];
                }
              }
            }
          }
        }
      }

      if ($this->remove_ordered_results) {
        unset($this->ordered_results);
      }
    }

    return $return;
  }

  /**
   * Return back a string of the query that is going to be ran.
   *
   * @param object $query
   *   SelectQueryInterface object.
   *
   * @return string
   *   Formatted query string.
   */
  private function _get_query_string(SelectQueryInterface $query) {
    $string = (string) $query;
    $arguments = $query->arguments();

    // Convert to regular SQL Syntax
    if (!empty($arguments) && is_array($arguments)) {
      foreach ($arguments as $placeholder => &$value) {
        if (is_string($value)) {
          $value = "'$value'";
        }
      }
      $string = strtr($string, $arguments);
      $string = str_replace(array(' {', '} ', "\n{", "}\n"), ' ', $string);
    }
    // Pretty print SQL.
    if (!class_exists('SqlFormatter')) {
      // Make the SqlFormatter class available.
      module_load_include('php', 'entityfieldqueryextra', 'sql_formatter/SqlFormatter');
    }
    if (!class_exists('SqlFormatter')) {
      $string = str_replace(', ', ",\n  ", $string);
      $string = str_replace(' AND ', "\n  AND ", $string);
    }
    else {
      $string = SqlFormatter::format($string, false) . "\n\n";
    }
    $string = str_replace(' ON ', "\n  ON ", $string);

    return $string;
  }
}
